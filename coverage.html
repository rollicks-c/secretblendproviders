
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bitwarden: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rollicks-c/secretblendproviders/bitwarden/api.go (0.0%)</option>
				
				<option value="file1">github.com/rollicks-c/secretblendproviders/bitwarden/client.go (0.0%)</option>
				
				<option value="file2">github.com/rollicks-c/secretblendproviders/bitwarden/requests.go (0.0%)</option>
				
				<option value="file3">github.com/rollicks-c/secretblendproviders/bitwarden/server.go (0.0%)</option>
				
				<option value="file4">github.com/rollicks-c/secretblendproviders/envvar/api.go (50.0%)</option>
				
				<option value="file5">github.com/rollicks-c/secretblendproviders/envvar/inject.go (100.0%)</option>
				
				<option value="file6">github.com/rollicks-c/secretblendproviders/internal/network/api.go (0.0%)</option>
				
				<option value="file7">github.com/rollicks-c/secretblendproviders/internal/network/network.go (0.0%)</option>
				
				<option value="file8">github.com/rollicks-c/secretblendproviders/onepassword/api.go (0.0%)</option>
				
				<option value="file9">github.com/rollicks-c/secretblendproviders/vault/api.go (0.0%)</option>
				
				<option value="file10">github.com/rollicks-c/secretblendproviders/vault/auth.go (0.0%)</option>
				
				<option value="file11">github.com/rollicks-c/secretblendproviders/vault/auth_approle.go (0.0%)</option>
				
				<option value="file12">github.com/rollicks-c/secretblendproviders/vault/auth_jwt.go (0.0%)</option>
				
				<option value="file13">github.com/rollicks-c/secretblendproviders/vault/auth_token.go (0.0%)</option>
				
				<option value="file14">github.com/rollicks-c/secretblendproviders/vault/auth_userpath.go (0.0%)</option>
				
				<option value="file15">github.com/rollicks-c/secretblendproviders/vault/client.go (0.0%)</option>
				
				<option value="file16">github.com/rollicks-c/secretblendproviders/vault/provider.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bitwarden

import (
        "fmt"
        "github.com/rollicks-c/configcove"
        "github.com/rollicks-c/secretblend"
        "net/http"
        "strings"
)

type Client struct {
        apiServer *apiServer
}

type Option func(c *Client)

func Register() error <span class="cov0" title="0">{

        // use defaults
        appID := "bitwarden"
        dataDir := configcove.ConfigDir(appID)

        // register client
        bw, err := NewClient(dataDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">secretblend.AddProvider(bw, "bitwarden://")

        return nil</span>
}

func NewClient(dataDir string, options ...Option) (*Client, error) <span class="cov0" title="0">{

        // start api server
        server := &amp;apiServer{
                dataDir: dataDir,
        }
        if err := server.start(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // create api client
        <span class="cov0" title="0">client := &amp;Client{
                apiServer: server,
        }
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        // get ready to accept requests
        <span class="cov0" title="0">if err := client.init(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>

}

func (c Client) LoadSecret(uri string) (string, error) <span class="cov0" title="0">{
        parts := strings.Split(uri, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid uri: %s", uri)
        }</span>

        <span class="cov0" title="0">itemID := parts[0]
        item, err := c.GetItem(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">keyExp := parts[1]
        switch keyExp </span>{
        case "username":<span class="cov0" title="0">
                return item.Login.Username, nil</span>
        case "password":<span class="cov0" title="0">
                return item.Login.Password, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid key: %s", keyExp)</span>
        }

}

func (c Client) Check() error <span class="cov0" title="0">{

        ep := "/object/fingerprint/me"
        res := genericResponse{}
        if err := c.doTypedRequest(http.MethodGet, ep, nil, &amp;res); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return fmt.Errorf(res.Message)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func (c Client) IsLocked() (bool, error) <span class="cov0" title="0">{

        err := c.Check()
        if err == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err.Error() == "Vault is locked." </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov0" title="0">return false, nil</span>

}

func (c Client) Unlock(password string) error <span class="cov0" title="0">{
        ep := "/unlock"
        type request struct {
                Password string `json:"password"`
        }
        req := request{
                Password: password,
        }
        res := genericResponse{}
        if err := c.doTypedRequest(http.MethodPost, ep, req, &amp;res); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return fmt.Errorf(res.Message)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c Client) Find(exp string) ([]ItemData, error) <span class="cov0" title="0">{

        ep := fmt.Sprintf("/list/object/items?search=%s", exp)
        res := listResponse{}

        if err := c.doTypedRequest(http.MethodGet, ep, nil, &amp;res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get item: %v", res)
        }</span>
        <span class="cov0" title="0">return res.Data.Data, nil</span>

}

func (c Client) GetItem(id string) (ItemData, error) <span class="cov0" title="0">{

        ep := fmt.Sprintf("/object/item/%s", id)
        res := itemResponse{}
        if err := c.doTypedRequest(http.MethodGet, ep, nil, &amp;res); err != nil </span><span class="cov0" title="0">{
                return ItemData{}, err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return ItemData{}, fmt.Errorf("failed to get item: %v", res.Message)
        }</span>
        <span class="cov0" title="0">return res.Data, nil</span>

}

func (c Client) GetTOTP(id string) (TOTPData, error) <span class="cov0" title="0">{

        ep := fmt.Sprintf("/object/totp/%s", id)
        res := totpResponse{}
        if err := c.doTypedRequest(http.MethodGet, ep, nil, &amp;res); err != nil </span><span class="cov0" title="0">{
                return TOTPData{}, err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return TOTPData{}, fmt.Errorf("failed to get totp: %v", res)
        }</span>
        <span class="cov0" title="0">return res.Data, nil</span>

}

func (c Client) Sync() error <span class="cov0" title="0">{

        ep := "/sync"
        res := genericResponse{}

        if err := c.doTypedRequest(http.MethodPost, ep, nil, &amp;res); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync bw vault: %v", res)
        }</span>
        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bitwarden

import (
        "github.com/rollicks-c/term"
)

func (c Client) init() error <span class="cov0" title="0">{

        // check if already unlocked
        isLocked, err := c.IsLocked()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !isLocked </span><span class="cov0" title="0">{
                return nil

        }</span>

        // unlock with password
        <span class="cov0" title="0">pw, err := term.PromptSecret("enter bitwarden password")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := c.Unlock(pw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package bitwarden

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

type genericResponse struct {
        Success bool                   `json:"success"`
        Message string                 `json:"message"`
        Data    map[string]interface{} `json:"data"`
}

func (c Client) doRequest(method, ep string, body io.Reader) ([]byte, error) <span class="cov0" title="0">{

        // prep request
        url := fmt.Sprint(c.apiServer.getURL(), ep)
        req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // do request
        res, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        payload, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // done
        <span class="cov0" title="0">return payload, nil</span>
}

func (c Client) doTypedRequest(method, ep string, body interface{}, response interface{}) error <span class="cov0" title="0">{

        // prep payload
        var payloadRaw io.Reader
        if body != nil </span><span class="cov0" title="0">{
                payload, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err

                }</span>
                <span class="cov0" title="0">payloadRaw = bytes.NewReader(payload)</span>
        }

        // do request
        <span class="cov0" title="0">res, err := c.doRequest(method, ep, payloadRaw)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // parse response
        <span class="cov0" title="0">err = json.Unmarshal(res, response)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse response: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bitwarden

import (
        "bytes"
        "fmt"
        "github.com/rollicks-c/configcove"
        "github.com/rollicks-c/secretblendproviders/internal/network"
        "os"
        "os/exec"
        "syscall"
        "time"
)

type apiServer struct {
        dataDir string
}

const (
        appName = "sb.bitwarden"
)

func (s apiServer) start() error <span class="cov0" title="0">{

        // re-use existing
        pidCurrent, ok := configcove.Store(appName).LoadNumber("bitwarden.pid")
        if ok </span><span class="cov0" title="0">{
                if s.checkForRunningInstance(pidCurrent) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // create new
        <span class="cov0" title="0">pidNew, err := s.startInstance()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">configcove.Store(appName).SaveNumber("bitwarden.pid", pidNew)

        return nil</span>
}

func (s apiServer) startInstance() (int, error) <span class="cov0" title="0">{

        // prep command
        port := network.FindFreePort(8087)
        cmd := exec.Command("bw", "serve", "--port", fmt.Sprintf("%d", port))
        cmd.Env = append(cmd.Env, fmt.Sprintf("BITWARDENCLI_APPDATA_DIR=%s", s.dataDir))
        errorReader := &amp;bytes.Buffer{}
        cmd.Stderr = errorReader

        // own process group to not tear down after exit parent
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
        cmd.SysProcAttr.Setpgid = true

        // await start
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if err := s.awaitStart(cmd); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if err := s.awaitReadiness(errorReader); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return cmd.Process.Pid, nil</span>
}

func (s apiServer) checkForRunningInstance(pID int) bool <span class="cov0" title="0">{
        proc, err := os.FindProcess(pID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err := proc.Signal(syscall.Signal(0)); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (s apiServer) awaitStart(cmd *exec.Cmd) error <span class="cov0" title="0">{
        ticker := time.NewTicker(10 * time.Millisecond)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if cmd.Process != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                case &lt;-time.After(time.Second * 1):<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for server to start")</span>
                }
        }
}

func (s apiServer) awaitReadiness(errOut *bytes.Buffer) error <span class="cov0" title="0">{
        &lt;-time.After(time.Second * 1)
        if errOut.Len() &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("error starting server: %s", errOut.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s apiServer) getURL() string <span class="cov0" title="0">{
        return "http://localhost:8087"
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package envvar

import (
        "github.com/rollicks-c/secretblend"
)

type Client struct {
}

type Option func(c *Client)

func Register() error <span class="cov0" title="0">{

        // register client
        op := NewClient()
        secretblend.AddProvider(op, "envvar://")

        return nil
}</span>

func RegisterGlobally() error <span class="cov0" title="0">{

        // register client
        cl := NewClient()
        secretblend.AddGlobalProvider(cl)

        return nil
}</span>

func NewClient(options ...Option) *Client <span class="cov8" title="1">{

        // create client
        client := &amp;Client{}

        // apply options
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        <span class="cov8" title="1">return client</span>
}

func (c Client) LoadSecret(uri string) (string, error) <span class="cov8" title="1">{

        value, err := injectVars(uri)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package envvar

import (
        "fmt"
        "os"
        "regexp"
)

func injectVars(exp string) (string, error) <span class="cov8" title="1">{

        // regex to match $VAR or ${VAR}
        re := regexp.MustCompile(`\$\{?([a-zA-Z_][a-zA-Z0-9_]*)\}?`)

        // process all matches
        missingValues := []string{}
        result := re.ReplaceAllStringFunc(exp, func(match string) string </span><span class="cov8" title="1">{

                // get var name
                name := re.FindStringSubmatch(match)[1]

                // replace
                if value, exists := os.LookupEnv(name); exists </span><span class="cov8" title="1">{
                        return value
                }</span>

                // remember missing values
                <span class="cov8" title="1">missingValues = append(missingValues, name)
                return match</span>
        })

        // report missing values
        <span class="cov8" title="1">if len(missingValues) &gt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to load secret - envvars not provided: %s", missingValues)
        }</span>

        <span class="cov8" title="1">return result, nil</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package network

func FindFreePort(startPort int) int <span class="cov0" title="0">{
        for port := startPort; port &lt;= 65535; port++ </span><span class="cov0" title="0">{
                if isPortAvailable(port) </span><span class="cov0" title="0">{
                        return port
                }</span>
        }
        <span class="cov0" title="0">return -1</span> // No free port found
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package network

import (
        "fmt"
        "net"
)

func isPortAvailable(port int) bool <span class="cov0" title="0">{
        ln, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return false // Port is not available
        }</span>
        <span class="cov0" title="0">_ = ln.Close()
        return true</span> // Port is available
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package onepassword

import (
        "bytes"
        "fmt"
        "github.com/rollicks-c/secretblend"
        "os/exec"
        "strings"
)

type Client struct {
        cliPath string
}

type Option func(c *Client)

func Register() error <span class="cov0" title="0">{

        // use defaults
        cliPath := "op"

        // register client
        op := NewClient(cliPath)
        secretblend.AddProvider(op, "1password://")

        return nil
}</span>

func NewClient(cliPath string, options ...Option) *Client <span class="cov0" title="0">{

        // create cli client
        client := &amp;Client{
                cliPath: cliPath,
        }

        // apply options
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        <span class="cov0" title="0">return client</span>
}

func (c Client) LoadSecret(uri string) (string, error) <span class="cov0" title="0">{

        // gather data
        parts := strings.Split(uri, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid uri: %s", uri)
        }</span>
        <span class="cov0" title="0">itemID := parts[0]

        // sanity check
        field := parts[1]
        switch field </span>{
        case "username":<span class="cov0" title="0"></span>
        case "password":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid 1password field: %s", field)</span>
        }

        <span class="cov0" title="0">secret, err := c.GetItem(itemID, field)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return secret, nil</span>
}

func (c Client) GetItem(id, field string) (string, error) <span class="cov0" title="0">{

        // build command
        cmd := exec.Command("op", "item", "get", id, "--field", field, "--reveal")
        var out bytes.Buffer
        cmd.Stdout = &amp;out

        // run command
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get secret: %w", err)
        }</span>

        // extract
        <span class="cov0" title="0">secret := out.String()
        secret = strings.Trim(secret, "\n")
        return secret, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package vault

import (
        "fmt"
        "github.com/hashicorp/vault/api"
        "path"
)

type Secret map[string]string

type Client struct {
        authManager *authManager
}

type Option func(c *Client)

func NewClient(addr string, options ...Option) (*Client, error) <span class="cov0" title="0">{

        // create api client
        vtClient, err := api.NewClient(&amp;api.Config{
                Address: addr,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client := &amp;Client{
                authManager: newAuthManager(vtClient),
        }
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        <span class="cov0" title="0">if client.authManager.tokenProvider == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no token provider is set")
        }</span>

        <span class="cov0" title="0">if err := client.verifyToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>

}

func WithAppRole(roleID string, secretID string) Option <span class="cov0" title="0">{
        tp := tokenProviderAppRole{
                roleID:   roleID,
                secretID: secretID,
                authPath: "auth/approle/login",
        }
        return func(c *Client) </span><span class="cov0" title="0">{
                c.authManager.tokenProvider = tp
        }</span>
}

func WithUserPass(username, password string) Option <span class="cov0" title="0">{
        tp := tokenProviderUserPass{
                username: username,
                password: password,
                authPath: "auth/userpass/login",
        }
        return func(c *Client) </span><span class="cov0" title="0">{
                c.authManager.tokenProvider = tp
        }</span>
}

func WithJWT(authPath, role, jwt string) Option <span class="cov0" title="0">{
        tp := &amp;tokenProviderJWT{
                jwt:      jwt,
                role:     role,
                authPath: authPath,
        }
        return func(c *Client) </span><span class="cov0" title="0">{
                c.authManager.tokenProvider = tp
        }</span>
}

func WithToken(token string) Option <span class="cov0" title="0">{
        tp := tokenProviderDirect{
                token: token,
        }
        return func(c *Client) </span><span class="cov0" title="0">{
                if token == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">c.authManager.tokenProvider = tp</span>
        }
}

func (c Client) AsProvider() *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                client: &amp;c,
        }
}</span>

func (c Client) LoadSecretValue(uri string) (string, error) <span class="cov0" title="0">{

        vtPath := path.Dir(uri)
        key := path.Base(uri)

        data, err := c.loadSecret(vtPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">secret, ok := data[key]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("key not found: %s", key)
        }</span>

        <span class="cov0" title="0">return secret.(string), nil</span>
}

func (c Client) LoadSecret(path string) (Secret, error) <span class="cov0" title="0">{

        dataRaw, err := c.loadSecret(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]string{}
        for k, v := range dataRaw </span><span class="cov0" title="0">{
                data[k] = v.(string)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

func (c Client) ListSecretKeys(path string) ([]string, error) <span class="cov0" title="0">{

        // login to vault
        vt, err := c.authManager.getClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // apply path options
        <span class="cov0" title="0">path = c.fixMetaPathForV2(path)

        // retrieve secret
        res, err := vt.Logical().List(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // not found
        <span class="cov0" title="0">if res == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no value found at [%s]", path)
        }</span>

        // unpack
        <span class="cov0" title="0">DataRaw, ok := res.Data["keys"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid secret: %s", path)
        }</span>
        <span class="cov0" title="0">data := DataRaw.([]interface{})
        keys := make([]string, 0, len(data))
        for _, k := range data </span><span class="cov0" title="0">{
                keys = append(keys, k.(string))
        }</span>

        // found
        <span class="cov0" title="0">return keys, nil</span>

}

func (c Client) WriteSecret(path string, data Secret) error <span class="cov0" title="0">{

        // login to vault
        vt, err := c.authManager.getClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // pack secret
        <span class="cov0" title="0">payload := map[string]interface{}{
                "data": data,
        }

        // apply path options
        path = c.fixDataPathForV2(path)

        // write secret
        if _, err := vt.Logical().Write(path, payload); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (c Client) DeleteSecret(path string) error <span class="cov0" title="0">{

        // login to vault
        vt, err := c.authManager.getClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // apply path options
        //path = c.fixDataPathForV2(path)
        <span class="cov0" title="0">path = c.fixMetaPathForV2(path)

        // remove secret
        if _, err := vt.Logical().Delete(path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (c Client) ReadValue(path, field string) (interface{}, error) <span class="cov0" title="0">{

        vt, err := c.authManager.getClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // retrieve secret
        <span class="cov0" title="0">res, err := vt.Logical().Read(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // not found
        <span class="cov0" title="0">if res == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no value found at [%s]", path)
        }</span>

        // extract
        <span class="cov0" title="0">value, ok := res.Data[field]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("field %s not found at %s", field, path)
        }</span>

        // found
        <span class="cov0" title="0">return value, nil</span>

}

func CompareSecrets(s1, s2 Secret) bool <span class="cov0" title="0">{
        if len(s1) != len(s2) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for k, v := range s1 </span><span class="cov0" title="0">{
                if s2v, ok := s2[k]; !ok || s2v != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package vault

import (
        "fmt"
        "github.com/hashicorp/vault/api"
        "sync"
        "time"
)

type tokenProvider interface {
        Authenticate(apiClient *api.Client) (*api.SecretAuth, error)
}

type authManager struct {
        tokenProvider tokenProvider
        token         string
        tokenExp      *time.Time
        apiClient     *api.Client
        lock          sync.Mutex
}

func newAuthManager(apiClient *api.Client) *authManager <span class="cov0" title="0">{
        return &amp;authManager{
                apiClient: apiClient,
                lock:      sync.Mutex{},
        }
}</span>

func (am *authManager) getClient() (*api.Client, error) <span class="cov0" title="0">{

        am.lock.Lock()
        defer am.lock.Unlock()

        if err := am.refreshToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return am.apiClient, nil</span>
}

func (am *authManager) refreshToken() error <span class="cov0" title="0">{

        if err := am.validateToken(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := am.renewToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *authManager) validateToken() error <span class="cov0" title="0">{

        if am.token == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no token set")
        }</span>
        <span class="cov0" title="0">if am.tokenExp == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no token meta dataa set")
        }</span>
        <span class="cov0" title="0">if am.tokenExp.Before(time.Now()) </span><span class="cov0" title="0">{
                return fmt.Errorf("token has expired")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *authManager) renewToken() error <span class="cov0" title="0">{

        // reset
        am.token = ""
        am.tokenExp = nil

        // gather token
        auth, err := am.tokenProvider.Authenticate(am.apiClient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">am.token = auth.ClientToken
        am.apiClient.SetToken(auth.ClientToken)

        // gather meta data
        tokenMeta, err := am.apiClient.Auth().Token().LookupSelf()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ttl, err := tokenMeta.TokenTTL()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">expire := time.Now().Add(ttl).Add(time.Second * -5)

        expire = time.Now().Add(time.Duration(auth.LeaseDuration) * time.Second).Add(time.Second * -5)

        // use token
        am.tokenExp = &amp;expire
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package vault

import (
        "github.com/hashicorp/vault/api"
)

type tokenProviderAppRole struct {
        roleID   string
        secretID string
        authPath string
}

func (tar tokenProviderAppRole) Authenticate(apiClient *api.Client) (*api.SecretAuth, error) <span class="cov0" title="0">{

        // login and get a token
        tokenData, err := apiClient.Logical().Write(tar.authPath, map[string]interface{}{
                "role_id":   tar.roleID,
                "secret_id": tar.secretID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // extract token and use
        <span class="cov0" title="0">return tokenData.Auth, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package vault

import (
        "github.com/hashicorp/vault/api"
)

type tokenProviderJWT struct {
        jwt      string
        authPath string
        role     string
        token    string
}

func (tp *tokenProviderJWT) Authenticate(apiClient *api.Client) (*api.SecretAuth, error) <span class="cov0" title="0">{
        args := map[string]any{
                "jwt":  tp.jwt,
                "role": tp.role,
        }
        secret, err := apiClient.Logical().Write(tp.authPath, args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return secret.Auth, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package vault

import (
        "github.com/hashicorp/vault/api"
)

type tokenProviderDirect struct {
        token string
}

func (td tokenProviderDirect) Authenticate(apiClient *api.Client) (*api.SecretAuth, error) <span class="cov0" title="0">{
        auth := &amp;api.SecretAuth{
                ClientToken:   td.token,
                LeaseDuration: 60 * 60,
        }
        return auth, nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package vault

import (
        "fmt"
        "github.com/hashicorp/vault/api"
)

type tokenProviderUserPass struct {
        username string
        password string
        authPath string
}

func (up tokenProviderUserPass) Authenticate(apiClient *api.Client) (*api.SecretAuth, error) <span class="cov0" title="0">{

        // login and get a token
        authPath := fmt.Sprintf("%s/%s", up.authPath, up.username)
        tokenData, err := apiClient.Logical().Write(authPath, map[string]interface{}{
                "password": up.password,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // extract token and use
        <span class="cov0" title="0">return tokenData.Auth, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package vault

import (
        "fmt"
        "strings"
)

func (c Client) verifyToken() error <span class="cov0" title="0">{
        return c.authManager.refreshToken()
}</span>

func (c Client) loadSecret(path string) (map[string]interface{}, error) <span class="cov0" title="0">{

        // login to vault
        vt, err := c.authManager.getClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // apply path options
        <span class="cov0" title="0">path = c.fixDataPathForV2(path)

        // retrieve secret
        res, err := vt.Logical().Read(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // not found
        <span class="cov0" title="0">if res == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // unpack
        <span class="cov0" title="0">secretDataRaw, ok := res.Data["data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid secret: %s", path)
        }</span>
        <span class="cov0" title="0">if secretDataRaw == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("found empty secret: %s", path)
                return nil, err
        }</span>
        <span class="cov0" title="0">secretData := secretDataRaw.(map[string]interface{})

        // found
        return secretData, nil</span>

}

func (c Client) fixDataPathForV2(secretPath string) string <span class="cov0" title="0">{
        secretPath = strings.TrimPrefix(secretPath, "/")
        parts := strings.Split(secretPath, "/")
        parts = append([]string{parts[0], "data"}, parts[1:]...)
        secretPath = strings.Join(parts, "/")
        return secretPath
}</span>

func (c Client) fixMetaPathForV2(secretPath string) string <span class="cov0" title="0">{
        secretPath = strings.TrimPrefix(secretPath, "/")
        parts := strings.Split(secretPath, "/")
        parts = append([]string{parts[0], "metadata"}, parts[1:]...)
        secretPath = strings.Join(parts, "/")
        return secretPath
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package vault

type Provider struct {
        client *Client
}

func (p Provider) LoadSecret(uri string) (string, error) <span class="cov0" title="0">{
        return p.client.LoadSecretValue(uri)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
